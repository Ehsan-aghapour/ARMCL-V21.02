/****************************************************************************
*   Generated by ACUITY 5.11.0
*   Match ovxlib 1.1.21
*
*   Neural Network appliction pre-process source file
****************************************************************************/
/*-------------------------------------------
                Includes
-------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "jpeglib.h"
#include "vsi_nn_pub.h"
#include "vnn_global.h"
#include "vnn_pre_process.h"

#define _BASETSD_H

/*-------------------------------------------
                  Variable definitions
-------------------------------------------*/

/*{graph_input_idx, preprocess}*/
const static vsi_nn_preprocess_map_element_t* preprocess_map = NULL;

/*-------------------------------------------
                  Functions
-------------------------------------------*/
#define INPUT_META_NUM 1
static vnn_input_meta_t input_meta_tab[INPUT_META_NUM];
static void _load_input_meta()
{
    uint32_t i;
    for (i = 0; i < INPUT_META_NUM; i++)
    {
        memset(&input_meta_tab[i].image.preprocess,
            VNN_PREPRO_NONE, sizeof(int32_t) * VNN_PREPRO_NUM);
    }
    /* lid: attach_input/out0_1 */
    input_meta_tab[0].image.preprocess[0] = VNN_PREPRO_REORDER;
    input_meta_tab[0].image.preprocess[1] = VNN_PREPRO_MEAN;
    input_meta_tab[0].image.preprocess[2] = VNN_PREPRO_SCALE;
    input_meta_tab[0].image.reorder[0] = 0;
    input_meta_tab[0].image.reorder[1] = 1;
    input_meta_tab[0].image.reorder[2] = 2;
    input_meta_tab[0].image.mean[0] = 128.0;
    input_meta_tab[0].image.mean[1] = 128.0;
    input_meta_tab[0].image.mean[2] = 128.0;
    input_meta_tab[0].image.scale = 0.0078125;


}

static vsi_enum _get_file_type(const char *file_name)
{
    vsi_enum type = 0;
    const char *ptr;
    char sep = '.';
    uint32_t pos,n;
    char buff[32] = {0};

    ptr = strrchr(file_name, sep);
    pos = ptr - file_name;
    n = strlen(file_name) - (pos + 1);
    strncpy(buff, file_name+(pos+1), n);

    if(strcmp(buff, "jpg") == 0
        || strcmp(buff, "jpeg") == 0
        || strcmp(buff, "JPG") == 0
        || strcmp(buff, "JPEG") == 0 )
    {
        type = NN_FILE_JPG;
    }
    else if(strcmp(buff, "tensor") == 0
        || strcmp(buff, "txt") == 0)
    {
        char *qnt_suffix = ".qnt.tensor";
        ptr = strstr(file_name, qnt_suffix);
        if(ptr && strlen(qnt_suffix))
        {
            type = NN_FILE_QTENSOR;
        }
        else
        {
            type = NN_FILE_TENSOR;
        }
    }
    else if(strcmp(buff, "qtensor") == 0)
    {
        type = NN_FILE_QTENSOR;
    }
    else if(strcmp(buff, "bin") == 0
        || strcmp(buff, "dat") == 0)
    {
        type = NN_FILE_BINARY;
    }
    else
    {
        type = NN_FILE_NONE;
    }

    return type;
}

static void _get_jpeg_size
    (
    const char *name,
    uint32_t* bmpWidth,
    uint32_t* bmpHeight,
    uint32_t* channel
    )
{
    FILE *jpgFile = NULL;
    struct jpeg_decompress_struct cinfo;
    struct jpeg_error_mgr jerr;

    jpgFile = fopen( name, "rb" );
    TEST_CHECK_PTR(jpgFile, final);

    cinfo.err = jpeg_std_error(&jerr);
    jpeg_create_decompress(&cinfo);
    jpeg_stdio_src(&cinfo,jpgFile);
    jpeg_read_header(&cinfo,TRUE);

    cinfo.dct_method = JDCT_IFAST;
    jpeg_start_decompress(&cinfo);

    *bmpWidth  = cinfo.output_width;
    *bmpHeight = cinfo.output_height;
    *channel  = cinfo.output_components;
    jpeg_destroy_decompress(&cinfo);

final:
    if (jpgFile) fclose(jpgFile);
}

static vsi_status _jpeg_to_bmp
    (
    FILE * inputFile,
    unsigned char* bmpData,
    uint32_t bmpWidth,
    uint32_t bmpHeight,
    uint32_t channel
    )
{
    struct jpeg_decompress_struct cinfo;
    struct jpeg_error_mgr jerr;
    JSAMPARRAY buffer;
    unsigned char *point = NULL;
    unsigned long width, height;
    unsigned short depth = 0;

    cinfo.err = jpeg_std_error(&jerr);
    jpeg_create_decompress(&cinfo);
    jpeg_stdio_src(&cinfo,inputFile);
    jpeg_read_header(&cinfo,TRUE);

    cinfo.dct_method = JDCT_IFAST;

    if (bmpData == NULL)
    {
        return VSI_FAILURE;
    }
    else
    {
        jpeg_start_decompress(&cinfo);

        width  = cinfo.output_width;
        height = cinfo.output_height;
        depth  = cinfo.output_components;
        if(width * height * depth != bmpWidth * bmpHeight * channel)
        {
           printf("wrong jpg file , the jpg file size should be %u %u %u\n",
               bmpWidth, bmpHeight, channel);
           return VSI_FAILURE;
        }

        buffer = (*cinfo.mem->alloc_sarray)
            ((j_common_ptr)&cinfo, JPOOL_IMAGE, width*depth, 1);

        point = bmpData;

        while (cinfo.output_scanline < height)
        {
            jpeg_read_scanlines(&cinfo, buffer, 1);
            memcpy(point, *buffer, width * depth);
            point += width * depth;
        }

        jpeg_finish_decompress(&cinfo);
    }

    jpeg_destroy_decompress(&cinfo);

    return VSI_SUCCESS;
}

static uint8_t *_float32_to_dtype
    (
    float *fdata,
    vsi_nn_tensor_t *tensor
    )
{
    vsi_status status;
    uint8_t *data;
    uint32_t sz,i,stride;

    sz = vsi_nn_GetElementNum(tensor);
    stride = vsi_nn_TypeGetBytes(tensor->attr.dtype.vx_type);
    data = (uint8_t *)malloc(stride * sz * sizeof(uint8_t));
    TEST_CHECK_PTR(data, final);
    memset(data, 0, stride * sz * sizeof(uint8_t));

    for(i = 0; i < sz; i++)
    {
        status = vsi_nn_Float32ToDtype(fdata[i], &data[stride * i], &tensor->attr.dtype);
        if(status != VSI_SUCCESS)
        {
            if(data)free(data);
            return NULL;
        }
    }

final:
    return data;
}

static float *_imageData_to_float32
    (
    uint8_t *bmpData,
    vsi_nn_tensor_t *tensor
    )
{
    float *fdata;
    uint32_t sz,i;

    fdata = NULL;
    sz = vsi_nn_GetElementNum(tensor);
    fdata = (float *)malloc(sz * sizeof(float));
    TEST_CHECK_PTR(fdata, final);

    for(i = 0; i < sz; i++)
    {
        fdata[i] = (float)bmpData[i];
    }

final:
    return fdata;
}

/*
    jpg file --> BMP data(dataformat: RGBRGBRGB...)
*/
static uint8_t *_decode_jpeg
    (
    const char *name,
    vsi_nn_tensor_t *tensor
    )
{
    FILE *bmpFile;
    uint8_t *bmpData;
    uint32_t sz,w,h,c;
    vsi_status status;

    bmpFile = NULL;
    bmpData = NULL;
    w = tensor->attr.size[0];
    h = tensor->attr.size[1];
    c = tensor->attr.size[2];
    sz = vsi_nn_GetElementNum(tensor);

    bmpFile = fopen( name, "rb" );
    TEST_CHECK_PTR(bmpFile, final);

    bmpData = (uint8_t *)malloc(sz * sizeof(uint8_t));
    TEST_CHECK_PTR(bmpData, final);
    memset(bmpData, 0, sz * sizeof(uint8_t));

    status = _jpeg_to_bmp( bmpFile, bmpData, w, h, c);
    if(status == VSI_FAILURE)
    {
        free(bmpData);
        fclose(bmpFile);
        return NULL;
    }

final:
    if(bmpFile)fclose(bmpFile);
    return bmpData;
}

static void _prepare_imageprocess_params
    (
    vsi_nn_imageprocess_param *imageprocess,
    int32_t *crop_start,
    int32_t *crop_length,
    int32_t *resize_length
    )
{
    float scale       = input_meta_tab[0].image.scale;
    float *mean_value = input_meta_tab[0].image.mean;
    uint32_t *reorder = input_meta_tab[0].image.reorder;

    imageprocess->platform_type = VSI_NN_PLATFORM_TENSORFLOW;
    imageprocess->crop.enable = TRUE;
    imageprocess->crop.dim_num = 4;
    imageprocess->crop.start = crop_start;
    imageprocess->crop.length = crop_length;

    if (mean_value[0] != 0 &&
        mean_value[1] != 0 &&
        mean_value[2] != 0 )
    {
        imageprocess->mean.type = VSI_NN_IMAGEPROCESS_MEAN_CHANNEL;
        imageprocess->mean.mean_value_size = 3;
        imageprocess->mean.mean_value = mean_value;
    }
    else
    {
        imageprocess->mean.type = VSI_NN_IMAGEPROCESS_MEAN_NONE;
    }
    if (scale == 0.0)
    {
        imageprocess->mean.scale = 1.0f;
    }
    else
    {
        imageprocess->mean.scale = scale;
    }

    imageprocess->resize.type = VSI_NN_IMAGEPROCESS_RESIZE_BILINEAR;
    imageprocess->resize.dim_num = 2;
    imageprocess->resize.length = resize_length;
    imageprocess->reverse_channel = FALSE;
    if (reorder[0] == 0 && reorder[1] == 1 && reorder[2] == 2)
    {
        imageprocess->reverse_channel = vx_true_e;
    }
}

static void _data_scale
    (
    float *fdata,
    vnn_input_meta_t *meta,
    vsi_nn_tensor_t *tensor
    )
{
    uint32_t i,sz;
    float val,scale;

    sz = vsi_nn_GetElementNum(tensor);
    scale = meta->image.scale;
    if(0 != scale)
    {
        for(i = 0; i < sz; i++)
        {
            val = fdata[i] * scale;
            fdata[i] = val;
        }
    }
}

static void _data_mean
    (
    float *fdata,
    vnn_input_meta_t *meta,
    vsi_nn_tensor_t *tensor
    )
{
    uint32_t s0,s1,s2;
    uint32_t i,j,offset;
    float val,mean;

    s0 = tensor->attr.size[0];
    s1 = tensor->attr.size[1];
    s2 = tensor->attr.size[2];

    for(i = 0; i < s2 * s1; i++)
    {
        offset = s0 * i;
        for (j = 0; j < s0; j++)
        {
            mean = meta->image.mean[j];
            val = fdata[offset + j] - mean;
            fdata[offset + j] = val;
        }
    }

}

/*
    caffe: transpose + reorder
    tf: reorder
*/
static void _data_transform
    (
    float *fdata,
    vnn_input_meta_t *meta,
    vsi_nn_tensor_t *tensor
    )
{
    uint32_t s0,s1,s2;
    uint32_t i,j,offset,sz,order;
    float *data;
    uint32_t *reorder;

    data = NULL;
    reorder = meta->image.reorder;
    s0 = tensor->attr.size[0];
    s1 = tensor->attr.size[1];
    s2 = tensor->attr.size[2];
    sz = vsi_nn_GetElementNum(tensor);
    data = (float *)malloc(sz * sizeof(float));
    TEST_CHECK_PTR(data, final);
    memset(data, 0, sizeof(float) * sz);

    for(i = 0; i < s2 * s1; i++)
    {
        offset = s0 * i;
        for (j = 0; j < s0; j++)
        {
            if(s0 > 1 && reorder[j] <= s0)
            {
                order = reorder[j];
            }
            else
            {
                order = j;
            }
            data[offset + j] = fdata[offset + order];
        }
    }


    memcpy(fdata, data, sz * sizeof(float));
final:
    if(data)free(data);
}

static uint8_t *_get_binary_data
    (
    vsi_nn_tensor_t *tensor,
    const char *name
    )
{
    uint8_t *tensorData;
    uint32_t sz,stride,ret,total_sz;
    FILE *tensorFile;

    tensorData = NULL;
    tensorFile = fopen(name, "rb");
    TEST_CHECK_PTR(tensorFile, error);

    sz = vsi_nn_GetElementNum(tensor);
    stride = vsi_nn_TypeGetBytes(tensor->attr.dtype.vx_type);
    total_sz = sz * stride;
    tensorData = (uint8_t *)malloc(total_sz * sizeof(uint8_t));
    TEST_CHECK_PTR(tensorData, error);

    memset(tensorData, 0, total_sz * sizeof(uint8_t));
    ret = fread(tensorData, 1, total_sz, tensorFile);
    if(ret != total_sz)
    {
        printf("Read %s fail\n", name);
        printf("read data %u != tensor sz %u\n", ret, total_sz);
        if(tensorData)free(tensorData);
        goto error;
    }

    if(tensorFile)fclose(tensorFile);
    return tensorData;
error:
    if(tensorFile)fclose(tensorFile);
    return NULL;
}

static uint8_t *_get_qtensor_data
    (
    vsi_nn_tensor_t *tensor,
    const char *name
    )
{
    uint32_t i = 0;
    float fval = 0.0;
    uint8_t *tensorData;
    uint32_t sz = 1,stride = 1;
    FILE *tensorFile;
    uint16_t uint16_temp_value = 0;
    int16_t int16_temp_value = 0;

    tensorData = NULL;
    tensorFile = fopen(name, "rb");
    TEST_CHECK_PTR(tensorFile, error);

    sz = vsi_nn_GetElementNum(tensor);
    stride = vsi_nn_TypeGetBytes(tensor->attr.dtype.vx_type);
    tensorData = (uint8_t *)malloc(sz * stride * sizeof(uint8_t));
    TEST_CHECK_PTR(tensorData, error);
    memset(tensorData, 0, sz * stride * sizeof(uint8_t));

    for(i = 0; i < sz; i++)
    {
        if(fscanf( tensorFile, "%f ", &fval ) != 1)
        {
            printf("Read tensor file fail.\n");
            printf("Please check file lines or if the file contains illegal characters\n");
            goto error;
        }
        if(1 == stride)
        {
            if(VSI_NN_TYPE_INT8 == tensor->attr.dtype.vx_type)
                tensorData[i * stride] = (int8_t)fval;
            else
                tensorData[i * stride] = (uint8_t)fval;
        }
        else if(2 == stride)
        {
            if(VSI_NN_TYPE_INT16 == tensor->attr.dtype.vx_type)
            {
                int16_temp_value = (int16_t)fval;
                memcpy(tensorData + i * stride, &int16_temp_value, stride * sizeof(uint8_t));
            }
            else
            {
                uint16_temp_value = (uint16_t)fval;
                memcpy(tensorData + i * stride, &uint16_temp_value, stride * sizeof(uint8_t));
            }
        }
        else
        {
            printf("Do not support quant data with length of %u.\n", stride);
            goto error;
        }
    }

    if(tensorFile)fclose(tensorFile);
    return tensorData;
error:
    if(tensorFile)fclose(tensorFile);
    return NULL;
}

static uint8_t *_get_tensor_data
    (
    vsi_nn_tensor_t *tensor,
    const char *name
    )
{
    vsi_status status = VSI_FAILURE;
    uint32_t i = 0;
    float fval = 0.0;
    uint8_t *tensorData;
    uint32_t sz = 1;
    uint32_t stride = 1;
    FILE *tensorFile;

    tensorData = NULL;
    tensorFile = fopen(name, "rb");
    TEST_CHECK_PTR(tensorFile, error);

    sz = vsi_nn_GetElementNum(tensor);
    stride = vsi_nn_TypeGetBytes(tensor->attr.dtype.vx_type);
    tensorData = (uint8_t *)malloc(stride * sz * sizeof(uint8_t));
    TEST_CHECK_PTR(tensorData, error);
    memset(tensorData, 0, stride * sz * sizeof(uint8_t));

    for(i = 0; i < sz; i++)
    {
        if(fscanf( tensorFile, "%f ", &fval ) != 1)
        {
            printf("Read tensor file fail.\n");
            printf("Please check file lines or if the file contains illegal characters\n");
            goto error;
        }
        status = vsi_nn_Float32ToDtype(fval, &tensorData[stride * i], &tensor->attr.dtype);
        TEST_CHECK_STATUS(status, error);
    }

    if(tensorFile)fclose(tensorFile);
    return tensorData;
error:
    if(tensorFile)fclose(tensorFile);
    return NULL;
}

static uint8_t *_get_jpeg_data
    (
    vsi_nn_tensor_t *tensor,
    vnn_input_meta_t *meta,
    const char *filename
    )
{
    uint32_t i;
    uint8_t *bmpData,*data;
    float *fdata;
    int32_t use_image_process = vnn_UseImagePreprocessNode();

    bmpData = NULL;
    fdata = NULL;
    data = NULL;

    bmpData = _decode_jpeg(filename, tensor);
    TEST_CHECK_PTR(bmpData, final);

    if(use_image_process)
    {
        data = bmpData;
        goto final;
    }

    fdata = _imageData_to_float32(bmpData, tensor);
    TEST_CHECK_PTR(fdata, final);

    for(i = 0; i < _cnt_of_array(meta->image.preprocess); i++)
    {
        switch (meta->image.preprocess[i])
        {
        case VNN_PREPRO_NONE:
            break;
        case VNN_PREPRO_REORDER:
            _data_transform(fdata, meta, tensor);
            break;
        case VNN_PREPRO_MEAN:
            _data_mean(fdata, meta, tensor);
            break;
        case VNN_PREPRO_SCALE:
            _data_scale(fdata, meta, tensor);
            break;
        default:
            break;
        }
    }

    data = _float32_to_dtype(fdata, tensor);
    TEST_CHECK_PTR(data, final);
final:
    if(fdata)
    {
        free(fdata);
        fdata = NULL;
    }
    if(use_image_process)
    {
        ;
    }
    else
    {
        if(bmpData)
        {
            free(bmpData);
            bmpData = NULL;
        }
    }

    return data;
}

#define IMAGE_ADDR_ALIGN_START_SIZE 64
#define IMAGE_ADDR_ALIGN_BLOCK_SIZE 64

static uint8_t *buffer_img = NULL;
static uint8_t *buffer_img_align_addr = NULL;

static void _get_image_handle_buffer
    (
    uint32_t width,
    uint32_t height,
    uint32_t channels,
    uint32_t align_start_size,
    uint32_t align_block_size
    )
{
    uint32_t sz;
    uint64_t temp;

    sz = width * height * channels + align_start_size + align_block_size;
    buffer_img = (uint8_t *)malloc( sz * sizeof( uint8_t ) );
    memset(buffer_img, 0, sizeof( uint8_t ) * sz);

    temp = (uint64_t)(buffer_img) % align_start_size;
    if (temp == 0)
    {
        buffer_img_align_addr = buffer_img;
    }
    else
    {
        buffer_img_align_addr = buffer_img + align_start_size - temp;
    }
}

static void _get_jpeg_image_align
    (
    const char *name,
    uint32_t width,
    uint32_t height,
    uint32_t channels
    )
{
    FILE *bmpFile;

    bmpFile = NULL;
    bmpFile = fopen( name, "rb" );
    TEST_CHECK_PTR(bmpFile, final);

    if (buffer_img == NULL)
    {
        _get_image_handle_buffer(width, height, channels,
            IMAGE_ADDR_ALIGN_START_SIZE, IMAGE_ADDR_ALIGN_BLOCK_SIZE);
    }

    _jpeg_to_bmp(bmpFile, buffer_img_align_addr, width, height, channels);

final:
    if(bmpFile)fclose(bmpFile);
}

static vsi_status _handle_multiple_inputs
    (
    vsi_nn_graph_t *graph,
    uint32_t idx,
    const char *input_file
    )
{
    vsi_status status;
    vsi_nn_tensor_t *tensor;
    uint8_t *data;
    vnn_input_meta_t meta;
    vsi_enum fileType;
    char dumpInput[128];

    status = VSI_FAILURE;
    data = NULL;
    tensor = NULL;
    memset(&meta, 0, sizeof(vnn_input_meta_t));
    tensor = vsi_nn_GetTensor( graph, graph->input.tensors[idx] );
    meta = input_meta_tab[idx];
    fileType = _get_file_type(input_file);
    switch(fileType)
    {
    case NN_FILE_JPG:
        data = _get_jpeg_data(tensor, &meta, input_file);
        TEST_CHECK_PTR(data, final);
        break;
    case NN_FILE_TENSOR:
        data = _get_tensor_data(tensor, input_file);
        TEST_CHECK_PTR(data, final);
        break;
    case NN_FILE_QTENSOR:
        data = _get_qtensor_data(tensor, input_file);
        TEST_CHECK_PTR(data, final);
        break;
    case NN_FILE_BINARY:
        data = _get_binary_data(tensor, input_file);
        TEST_CHECK_PTR(data, final);
        break;
    default:
        printf("error input file type\n");
        break;
    }

    /* Copy the Pre-processed data to input tensor */
    status = vsi_nn_CopyDataToTensor(graph, tensor, data);
    TEST_CHECK_STATUS(status, final);

    /* Save the image data to file */
    snprintf(dumpInput, sizeof(dumpInput), "input_%d.dat", idx);
    vsi_nn_SaveTensorToBinary(graph, tensor, dumpInput);


    status = VSI_SUCCESS;
final:
    if(data)free(data);
    return status;
}

void vnn_ReleaseBufferImage()
{
    if (buffer_img) free(buffer_img);
    buffer_img = NULL;
}

vsi_bool vnn_UseImagePreprocessNode()
{
    int32_t use_img_process;
    char *use_img_process_s;
    use_img_process = 0; /* default is 0 */
    use_img_process_s = getenv("VSI_USE_IMAGE_PROCESS");
    if(use_img_process_s)
    {
        use_img_process = atoi(use_img_process_s);
    }
    if (use_img_process)
    {
        return TRUE;
    }
    return FALSE;
}

/*
    image process pipeline:
    1.crop
    2.resize
    3.(val-mean)*scale
    4.RGBRGBRGB ---> BBBGGGRRR
    5.revert channel: BBBGGGRRR ---> RRRGGGBBB
*/
vsi_status vnn_PreProcessInceptionV3_ImageProcess
    (
    vsi_nn_graph_t *graph,
    const char **inputs,
    uint32_t input_num
    )
{
    vsi_status status = VSI_FAILURE;
    vsi_enum fileType;
    vsi_nn_tensor_t *tensor;
    uint8_t *data = NULL;
    const char *image_name;

    if(1 != input_num)
    {
        return VSI_FAILURE;
    }

    _load_input_meta();
    image_name = inputs[0];
    tensor = vsi_nn_GetTensor( graph, graph->input.tensors[0] );
    fileType = _get_file_type(image_name);
    if(fileType == NN_FILE_JPG)
    {
        vsi_nn_tensor_attr_t attr;
        vsi_nn_imageprocess_param imageprocess;

        _get_jpeg_size(image_name, &(attr.size[0]), &(attr.size[1]),
            &(attr.size[2]));

        /* src image size */
        //attr.size[0] = tensor->attr.size[0];
        //attr.size[1] = tensor->attr.size[1];
        //attr.size[2] = 3;
        attr.size[3] = 1;
        attr.dim_num = 4;

        {
            int32_t crop_start[] = {0, 0, 0, 0};
            int32_t crop_length[] = {attr.size[0], attr.size[1], 3, 1};
            int32_t resize_length[] = {tensor->attr.size[0], tensor->attr.size[1]};

            _prepare_imageprocess_params(&imageprocess, crop_start, crop_length,
                resize_length);
             _get_jpeg_image_align(image_name, attr.size[0], attr.size[1], attr.size[2]);
            status = vsi_nn_op_imageprocess_single_node(graph, &attr, &imageprocess,
                buffer_img_align_addr, tensor);
        }
    }
    else
    {
        printf("vnn_PreProcessInceptionV3_ImageProcess Only support JPG image file\n");
        status = VSI_FAILURE;
        TEST_CHECK_STATUS(status, final);
    }

final:
    if(data)free(data);
    return status;
}

vsi_status vnn_PreProcessInceptionV3
    (
    vsi_nn_graph_t *graph,
    const char **inputs,
    uint32_t input_num
    )
{
    uint32_t i;
    vsi_status status;

    status = VSI_FAILURE;
    _load_input_meta();
    if(input_num != graph->input.num)
    {
        //printf("Graph need %u inputs, but enter %u inputs!!!\n",
        //       graph->input.num, input_num);
        //return status;
    }
    for(i = 0; i < input_num; i++)
    {
        status = _handle_multiple_inputs(graph, i, inputs[i]);
        TEST_CHECK_STATUS(status, final);
    }

    status = VSI_SUCCESS;
final:
    return status;
}

uint32_t vnn_LoadFP32DataFromTextFile
    (
    const char* fname,
    uint8_t** buffer_ptr,
    uint32_t* buffer_sz
    )
{
    float fval = 0.0;
    uint32_t i = 0;
    uint8_t* buffer = NULL;
    uint32_t item_ount = 0;
    uint32_t read_size = 0;
    uint32_t stride = sizeof(fval);
    FILE *fp = NULL;

    if(!fname || !buffer_ptr || !buffer_sz)
    {
        return read_size;
    }

    fp = fopen(fname, "rb");
    if(fp)
    {
        while(!feof(fp) && fscanf( fp, "%f ", &fval ) == 1)
        {
            item_ount++;
        }

        if(item_ount > 0)
        {
            read_size = item_ount * stride;
            buffer = (uint8_t *)malloc(read_size);
            if(buffer)
            {
                int fail_to_read = FALSE;

                fseek(fp, 0, SEEK_SET);
                for(i = 0; i < item_ount && !fail_to_read; i++)
                {
                    if(fscanf( fp, "%f ", (float *)&buffer[stride * i] ) != 1)
                    {
                        printf("Read tensor file fail.\n");
                        printf("Please check file lines or if the file contains illegal characters\n");
                        free(buffer);
                        fail_to_read = TRUE;
                        read_size = 0;
                        break;
                    }
                }

                if(!fail_to_read)
                {
                    *buffer_ptr = buffer;
                    *buffer_sz = read_size;
                }
            }
            else
            {
                read_size = 0;
                printf("Allocate memory fail!\n");
            }
        }
        else
        {
            printf("No available data found!\n");
        }
        fclose(fp);
    }
    else
    {
        printf("Fail to open %s\n", fname);
    }

    if(!read_size)
    {
        printf("Load data from %s fail!\n", fname);
    }

    return read_size;
}

uint32_t vnn_LoadRawDataFromBinaryFile
    (
    const char* fname,
    uint8_t** buffer_ptr,
    uint32_t* buffer_sz
    )
{
    FILE *fp = NULL;
    uint32_t fsize = 0;
    uint32_t read_size = 0;
    uint8_t* buffer = NULL;

    if(!fname || !buffer_ptr || !buffer_sz)
    {
        return fsize;
    }

    fp = fopen(fname, "rb");
    if(fp)
    {
        fsize = fseek(fp, 0, SEEK_END);
        fsize = ftell(fp);

        buffer = (uint8_t *)malloc(fsize);
        if(buffer)
        {
            fseek(fp, 0, SEEK_SET);
            read_size = fread(buffer, 1, fsize, fp);
            if(read_size == fsize)
            {
                *buffer_ptr = buffer;
                *buffer_sz = read_size;
            }
            else
            {
                fsize = 0;
                free(buffer);
                buffer = NULL;
            }
        }
        else
        {
            fsize = 0;
            printf("Allocate memory fail!\n");
        }

        if(fp)
        {
            fclose(fp);
        }
    }

    if(!fsize)
    {
        printf("Load data from %s fail!\n", fname);
    }
    return fsize;
}

const vsi_nn_preprocess_map_element_t * vnn_GetPrePorcessMap()
{
    return preprocess_map;
}

uint32_t vnn_GetPrePorcessMapCount()
{
    if (preprocess_map == NULL)
        return 0;
    else
        return sizeof(preprocess_map) / sizeof(vsi_nn_preprocess_map_element_t);
}


/****************************************************************************
*   Generated by ACUITY 5.11.0
*   Match ovxlib 1.1.21
*
*   Neural Network appliction post-process source file
****************************************************************************/
/*-------------------------------------------
                Includes
-------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "vsi_nn_pub.h"

#include "vnn_global.h"
#include "vnn_post_process.h"

#define _BASETSD_H

/*-------------------------------------------
                  Variable definitions
-------------------------------------------*/

/*{graph_output_idx, postprocess}*/
const static vsi_nn_postprocess_map_element_t* postprocess_map = NULL;


/*-------------------------------------------
                  Functions
-------------------------------------------*/
static void save_output_data(vsi_nn_graph_t *graph)
{
    uint32_t i;
#define _DUMP_FILE_LENGTH 1028
#define _DUMP_SHAPE_LENGTH 128
    char filename[_DUMP_FILE_LENGTH] = {0}, shape[_DUMP_SHAPE_LENGTH] = {0};
    vsi_nn_tensor_t *tensor;

    for(i = 0; i < graph->output.num; i++)
    {
        tensor = vsi_nn_GetTensor(graph, graph->output.tensors[i]);
        vsi_nn_ShapeToString( tensor->attr.size, tensor->attr.dim_num,
            shape, _DUMP_SHAPE_LENGTH, FALSE );
        snprintf(filename, _DUMP_FILE_LENGTH, "output%u_%s.dat", i, shape);
        vsi_nn_SaveTensorToBinary(graph, tensor, filename);

    }
}

static vsi_bool get_top
    (
    float *pfProb,
    float *pfMaxProb,
    uint32_t *pMaxClass,
    uint32_t outputCount,
    uint32_t topNum
    )
{
    uint32_t i, j, k;

    #define MAX_TOP_NUM 20
    if (topNum > MAX_TOP_NUM) return FALSE;

    memset(pfMaxProb, 0xfe, sizeof(float) * topNum);
    memset(pMaxClass, 0xff, sizeof(float) * topNum);

    for (j = 0; j < topNum; j++)
    {
        for (i=0; i<outputCount; i++)
        {
            for (k=0; k < topNum; k ++)
            {
                if(i == pMaxClass[k])
                    break;
            }

            if (k != topNum)
                continue;

            if (pfProb[i] > *(pfMaxProb+j))
            {
                *(pfMaxProb+j) = pfProb[i];
                *(pMaxClass+j) = i;
            }
        }
    }

    return TRUE;
}

static vsi_status show_top5
    (
    vsi_nn_graph_t *graph,
    vsi_nn_tensor_t *tensor
    )
{
    vsi_status status = VSI_FAILURE;
    uint32_t i,sz,stride;
    float *buffer = NULL;
    uint8_t *tensor_data = NULL;
    uint32_t MaxClass[5];
    float fMaxProb[5];
    uint32_t topk = 5;

    sz = 1;
    for(i = 0; i < tensor->attr.dim_num; i++)
    {
        sz *= tensor->attr.size[i];
    }

    if(topk > sz)
        topk = sz;

    stride = vsi_nn_TypeGetBytes(tensor->attr.dtype.vx_type);
    tensor_data = (uint8_t *)vsi_nn_ConvertTensorToData(graph, tensor);
    buffer = (float *)malloc(sizeof(float) * sz);

    for(i = 0; i < sz; i++)
    {
        status = vsi_nn_DtypeToFloat32(&tensor_data[stride * i], &buffer[i], &tensor->attr.dtype);
    }

    if (!get_top(buffer, fMaxProb, MaxClass, sz, topk))
    {
        printf("Fail to show result.\n");
        goto final;
    }

    printf(" --- Top%d ---\n", topk);
    for(i = 0; i< topk; i++)
    {
        printf("%3d: %8.6f\n", MaxClass[i], fMaxProb[i]);
    }
    status = VSI_SUCCESS;

final:
    if(tensor_data)vsi_nn_Free(tensor_data);
    if(buffer)free(buffer);
    return status;
}

vsi_status vnn_PostProcessInceptionV3(vsi_nn_graph_t *graph)
{
    vsi_status status = VSI_FAILURE;

    /* Show the top5 result */
    status = show_top5(graph, vsi_nn_GetTensor(graph, graph->output.tensors[0]));
    TEST_CHECK_STATUS(status, final);

    /* Save all output tensor data to txt file */
    save_output_data(graph);

final:
    return VSI_SUCCESS;
}

const vsi_nn_postprocess_map_element_t * vnn_GetPostPorcessMap()
{
    return postprocess_map;
}

uint32_t vnn_GetPostPorcessMapCount()
{
    if (postprocess_map == NULL)
       return 0;
    else
        return sizeof(postprocess_map) / sizeof(vsi_nn_postprocess_map_element_t);
}


/****************************************************************************
*   Generated by ACUITY 5.11.0
*   Match ovxlib 1.1.21
*
*   Neural Network appliction network definition source file
****************************************************************************/
/*-------------------------------------------
                   Includes
 -------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>

#include "vsi_nn_pub.h"

#include "vnn_global.h"
#include "vnn_inceptionv3.h"

/*-------------------------------------------
                   Macros
 -------------------------------------------*/

#define NEW_VXNODE(_node, _type, _in, _out, _uid) do {\
        _node = vsi_nn_AddNode( graph, _type, _in, _out, NULL );\
        _node->uid = (uint32_t)_uid; \
        if( NULL == _node ) {\
            goto error;\
        }\
    } while(0)

#define NEW_VIRTUAL_TENSOR(_id, _attr, _dtype) do {\
        memset( _attr.size, 0, VSI_NN_MAX_DIM_NUM * sizeof(uint32_t));\
        _attr.dim_num = VSI_NN_DIM_AUTO;\
        _attr.vtl = !VNN_APP_DEBUG;\
        _attr.is_const = FALSE;\
        _attr.dtype.vx_type = _dtype;\
        _id = vsi_nn_AddTensor( graph, VSI_NN_TENSOR_ID_AUTO,\
                & _attr, NULL );\
        if( VSI_NN_TENSOR_ID_NA == _id ) {\
            goto error;\
        }\
    } while(0)

// Set const tensor dims out of this macro.
#define NEW_CONST_TENSOR(_id, _attr, _dtype, _ofst, _size) do {\
        data = load_data( fp, _ofst, _size  );\
        _attr.vtl = FALSE;\
        _attr.is_const = TRUE;\
        _attr.dtype.vx_type = _dtype;\
        _id = vsi_nn_AddTensor( graph, VSI_NN_TENSOR_ID_AUTO,\
                & _attr, data );\
        free( data );\
        if( VSI_NN_TENSOR_ID_NA == _id ) {\
            goto error;\
        }\
    } while(0)

// Set generic tensor dims out of this macro.
#define NEW_NORM_TENSOR(_id, _attr, _dtype) do {\
        _attr.vtl = FALSE;\
        _attr.is_const = FALSE;\
        _attr.dtype.vx_type = _dtype;\
        _id = vsi_nn_AddTensor( graph, VSI_NN_TENSOR_ID_AUTO,\
                & _attr, NULL );\
        if( VSI_NN_TENSOR_ID_NA == _id ) {\
            goto error;\
        }\
    } while(0)

// Set generic tensor dims out of this macro.
#define NEW_NORM_TENSOR_FROM_HANDLE(_id, _attr, _dtype) do {\
        _attr.vtl = FALSE;\
        _attr.is_const = FALSE;\
        _attr.dtype.vx_type = _dtype;\
        _id = vsi_nn_AddTensorFromHandle( graph, VSI_NN_TENSOR_ID_AUTO,\
                & _attr, NULL );\
        if( VSI_NN_TENSOR_ID_NA == _id ) {\
            goto error;\
        }\
    } while(0)

#define NET_NODE_NUM            (1)
#define NET_NORM_TENSOR_NUM     (2)
#define NET_CONST_TENSOR_NUM    (0)
#define NET_VIRTUAL_TENSOR_NUM  (1)
#define NET_TOTAL_TENSOR_NUM    (NET_NORM_TENSOR_NUM + NET_CONST_TENSOR_NUM + NET_VIRTUAL_TENSOR_NUM)

/*-------------------------------------------
               Local Variables
 -------------------------------------------*/

/*-------------------------------------------
                  Functions
 -------------------------------------------*/
static uint8_t* load_data
    (
    FILE  * fp,
    size_t  ofst,
    size_t  sz
    )
{
    uint8_t* data;
    int32_t ret;
    data = NULL;
    if( NULL == fp )
    {
        return NULL;
    }

    ret = fseek(fp, ofst, SEEK_SET);
    if (ret != 0)
    {
        VSILOGE("blob seek failure.");
        return NULL;
    }

    data = (uint8_t*)malloc(sz);
    if (data == NULL)
    {
        VSILOGE("buffer malloc failure.");
        return NULL;
    }
    ret = fread(data, 1, sz, fp);
    return data;
} /* load_data() */

vsi_nn_graph_t * vnn_CreateInceptionV3
    (
    const char * data_file_name,
    vsi_nn_context_t in_ctx,
    const vsi_nn_preprocess_map_element_t * pre_process_map,
    uint32_t pre_process_map_count,
    const vsi_nn_postprocess_map_element_t * post_process_map,
    uint32_t post_process_map_count
    )
{
    vsi_status              status;
    vsi_bool                release_ctx;
    vsi_nn_context_t        ctx;
    vsi_nn_graph_t *        graph;
    vsi_nn_node_t *         node[NET_NODE_NUM];
    vsi_nn_tensor_id_t      norm_tensor[NET_NORM_TENSOR_NUM];
    
    vsi_nn_tensor_attr_t    attr;
    FILE *                  fp;
    uint8_t *               data;
    uint32_t                i = 0;
    char *                  use_img_process_s;
    int32_t                 enable_pre_post_process = 0;





    ctx = NULL;
    graph = NULL;
    status = VSI_FAILURE;
    memset( &attr, 0, sizeof( attr ) );

    fp = fopen( data_file_name, "rb" );
    if( NULL == fp )
    {
        VSILOGE( "Open file %s failed.", data_file_name );
        goto error;
    }

    if( NULL == in_ctx )
    {
        ctx = vsi_nn_CreateContext();
    }
    else
    {
        ctx = in_ctx;
    }

    graph = vsi_nn_CreateGraph( ctx, NET_TOTAL_TENSOR_NUM, NET_NODE_NUM );
    if( NULL == graph )
    {
        VSILOGE( "Create graph fail." );
        goto error;
    }
    vsi_nn_SetGraphVersion( graph, VNN_VERSION_MAJOR, VNN_VERSION_MINOR, VNN_VERSION_PATCH );
    vsi_nn_SetGraphInputs( graph, NULL, 1 );
    vsi_nn_SetGraphOutputs( graph, NULL, 1 );

/*-----------------------------------------
  Register client ops
 -----------------------------------------*/


/*-----------------------------------------
  Node definitions
 -----------------------------------------*/

    /*-----------------------------------------
      lid       - nbg_0
      var       - node[0]
      name      - nbg
      operation - nbg
      input     - [3, 299, 299, 1]
      output    - [1001, 1]
    -----------------------------------------*/
    NEW_VXNODE(node[0], VSI_NN_OP_NBG, 1, 1, 0);
    node[0]->nn_param.nbg.type = VSI_NN_NBG_FILE;
    node[0]->nn_param.nbg.url = data_file_name;


/*-----------------------------------------
  Tensor initialize
 -----------------------------------------*/
    attr.dtype.fmt = VSI_NN_DIM_FMT_NCHW;
    /* @attach_InceptionV3/Predictions/Reshape_1/out0_0:out0 */
    attr.size[0] = 1001;
    attr.size[1] = 1;
    attr.dim_num = 2;
    attr.dtype.qnt_type = VSI_NN_QNT_TYPE_NONE;
    NEW_NORM_TENSOR(norm_tensor[0], attr, VSI_NN_TYPE_FLOAT16);

    /* @attach_input/out0_1:out0 */
    attr.size[0] = 3;
    attr.size[1] = 299;
    attr.size[2] = 299;
    attr.size[3] = 1;
    attr.dim_num = 4;
    attr.dtype.scale = 0.007291667;
    attr.dtype.zero_point = 137;
    attr.dtype.qnt_type = VSI_NN_QNT_TYPE_AFFINE_ASYMMETRIC;
    NEW_NORM_TENSOR(norm_tensor[1], attr, VSI_NN_TYPE_UINT8);







/*-----------------------------------------
  Connection initialize
 -----------------------------------------*/
    node[0]->input.tensors[0] = norm_tensor[1];
    node[0]->output.tensors[0] = norm_tensor[0];

    /* nbg_0 */



    graph->output.tensors[0] = norm_tensor[0];
    graph->input.tensors[0] = norm_tensor[1];


    use_img_process_s = getenv( "VSI_USE_IMAGE_PROCESS" );
    if( use_img_process_s )
    {
        enable_pre_post_process = atoi(use_img_process_s);
    }
    if( enable_pre_post_process )
    {
        if( pre_process_map_count > 0 )
        {
            for( i = 0; i < pre_process_map_count; i++ )
            {
                status = vsi_nn_AddGraphPreProcess(graph, pre_process_map[i].graph_input_idx,
                                                   pre_process_map[i].preprocesses,
                                                   pre_process_map[i].preprocess_count);
                TEST_CHECK_STATUS( status, error );
            }
        }

        if( post_process_map_count > 0 )
        {
            for( i = 0; i < post_process_map_count; i++ )
            {
                 status = vsi_nn_AddGraphPostProcess(graph, post_process_map[i].graph_output_idx,
                                                     post_process_map[i].postprocesses,
                                                     post_process_map[i].postprocess_count);
                 TEST_CHECK_STATUS( status, error );
            }
        }

        status = vsi_nn_SetupGraph( graph, TRUE );
        TEST_CHECK_STATUS( status, error );
    }
    else
    {
        status = vsi_nn_SetupGraph( graph, FALSE );
        TEST_CHECK_STATUS( status, error );
    }

    if( VSI_FAILURE == status )
    {
        goto error;
    }

    fclose( fp );

    return graph;

error:
    if( NULL != fp )
    {
        fclose( fp );
    }

    release_ctx = ( NULL == in_ctx );
    vsi_nn_DumpGraphToJson( graph );
    vnn_ReleaseInceptionV3( graph, release_ctx );

    return NULL;
} /* vsi_nn_CreateInceptionV3() */

void vnn_ReleaseInceptionV3
    (
    vsi_nn_graph_t * graph,
    vsi_bool release_ctx
    )
{
    vsi_nn_context_t ctx;
    if( NULL != graph )
    {
        ctx = graph->ctx;
        vsi_nn_ReleaseGraph( &graph );

        /*-----------------------------------------
        Unregister client ops
        -----------------------------------------*/
        

        if( release_ctx )
        {
            vsi_nn_ReleaseContext( &ctx );
        }
    }
} /* vsi_nn_ReleaseInceptionV3() */




/****************************************************************************
*   Generated by ACUITY 5.11.0
*   Match ovxlib 1.1.21
*
*   Neural Network application project entry file
****************************************************************************/
/*-------------------------------------------
                Includes
-------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifdef __linux__
#include <time.h>
#elif defined(_WIN32)
#include <windows.h>
#endif

#define _BASETSD_H

#include "vsi_nn_pub.h"

#include "vnn_global.h"
#include "vnn_pre_process.h"
#include "vnn_post_process.h"
#include "vnn_inceptionv3.h"

/*-------------------------------------------
        Macros and Variables
-------------------------------------------*/

/*-------------------------------------------
                  Functions
-------------------------------------------*/
static void vnn_ReleaseNeuralNetwork
    (
    vsi_nn_graph_t *graph
    )
{
    vnn_ReleaseInceptionV3( graph, TRUE );
    if (vnn_UseImagePreprocessNode())
    {
        vnn_ReleaseBufferImage();
    }
}

static vsi_status vnn_PostProcessNeuralNetwork
    (
    vsi_nn_graph_t *graph
    )
{
    return vnn_PostProcessInceptionV3( graph );
}

#define BILLION                                 1000000000
static uint64_t get_perf_count()
{
#if defined(__linux__) || defined(__ANDROID__) || defined(__QNX__) || defined(__CYGWIN__)
    struct timespec ts;

    clock_gettime(CLOCK_MONOTONIC, &ts);

    return (uint64_t)((uint64_t)ts.tv_nsec + (uint64_t)ts.tv_sec * BILLION);
#elif defined(_WIN32) || defined(UNDER_CE)
    LARGE_INTEGER ln;

    QueryPerformanceCounter(&ln);

    return (uint64_t)ln.QuadPart;
#endif
}

static vsi_status vnn_VerifyGraph
    (
    vsi_nn_graph_t *graph
    )
{
    vsi_status status = VSI_FAILURE;
    uint64_t tmsStart, tmsEnd, msVal, usVal;

    /* Verify graph */
    printf("Verify...\n");
    tmsStart = get_perf_count();
    status = vsi_nn_VerifyGraph( graph );
    TEST_CHECK_STATUS(status, final);
    tmsEnd = get_perf_count();
    msVal = (tmsEnd - tmsStart)/1000000;
    usVal = (tmsEnd - tmsStart)/1000;
    printf("Verify Graph: %ldms or %ldus\n", msVal, usVal);

final:
    return status;
}

static vsi_status vnn_ProcessGraph
    (
    vsi_nn_graph_t *graph
    )
{
    vsi_status status = VSI_FAILURE;
    int32_t i,loop;
    char *loop_s;
    uint64_t tmsStart, tmsEnd, sigStart, sigEnd;
    float msVal, usVal;

    status = VSI_FAILURE;
    loop = 1; /* default loop time is 1 */
    loop_s = getenv("VNN_LOOP_TIME");
    if(loop_s)
    {
        loop = atoi(loop_s);
    }

    /* Run graph */
    tmsStart = get_perf_count();
    printf("Start run graph [%d] times...\n", loop);
    for(i = 0; i < loop; i++)
    {
        sigStart = get_perf_count();
        status = vsi_nn_RunGraph( graph );
        if(status != VSI_SUCCESS)
        {
            printf("Run graph the %d time fail\n", i);
        }
        TEST_CHECK_STATUS( status, final );

        sigEnd = get_perf_count();
        msVal = (sigEnd - sigStart)/1000000;
        usVal = (sigEnd - sigStart)/1000;
        printf("Run the %u time: %.2fms or %.2fus\n", (i + 1), msVal, usVal);
    }
    tmsEnd = get_perf_count();
    msVal = (tmsEnd - tmsStart)/1000000;
    usVal = (tmsEnd - tmsStart)/1000;
    printf("vxProcessGraph execution time:\n");
    printf("Total   %.2fms or %.2fus\n", msVal, usVal);
    printf("Average %.2fms or %.2fus\n", ((float)usVal)/1000/loop, ((float)usVal)/loop);

final:
    return status;
}

static vsi_status vnn_PreProcessNeuralNetwork
    (
    vsi_nn_graph_t *graph,
    int argc,
    char **argv
    )
{
    /*
     * argv0:   execute file
     * argv1:   data file
     * argv2~n: inputs n file
     */
    const char **inputs = (const char **)argv + 2;
    uint32_t input_num = argc - 2;

    /*
    if(vnn_UseImagePreprocessNode())
    {
        return vnn_PreProcessInceptionV3_ImageProcess(graph, inputs, input_num);
    }
    */
    return vnn_PreProcessInceptionV3( graph, inputs, input_num );
}

static vsi_nn_graph_t *vnn_CreateNeuralNetwork
    (
    const char *data_file_name
    )
{
    vsi_nn_graph_t *graph = NULL;
    uint64_t tmsStart, tmsEnd, msVal, usVal;

    tmsStart = get_perf_count();
    graph = vnn_CreateInceptionV3( data_file_name, NULL,
                      vnn_GetPrePorcessMap(), vnn_GetPrePorcessMapCount(),
                      vnn_GetPostPorcessMap(), vnn_GetPostPorcessMapCount() );
    TEST_CHECK_PTR(graph, final);
    tmsEnd = get_perf_count();
    msVal = (tmsEnd - tmsStart)/1000000;
    usVal = (tmsEnd - tmsStart)/1000;
    printf("Create Neural Network: %ldms or %ldus\n", msVal, usVal);

final:
    return graph;
}

/*-------------------------------------------
                  Main Functions
-------------------------------------------*/
int main
    (
    int argc,
    char **argv
    )
{
    vsi_status status = VSI_FAILURE;
    vsi_nn_graph_t *graph;
    const char *data_name = NULL;

    if(argc < 3)
    {
        printf("Usage: %s data_file inputs...\n", argv[0]);
        return -1;
    }

    data_name = (const char *)argv[1];

    /* Create the neural network */
    graph = vnn_CreateNeuralNetwork( data_name );
    TEST_CHECK_PTR( graph, final );

    /* Pre process the image data */
    status = vnn_PreProcessNeuralNetwork( graph, argc, argv );
    TEST_CHECK_STATUS( status, final );

    /* Verify graph */
    status = vnn_VerifyGraph( graph );
    TEST_CHECK_STATUS( status, final);

    /* Process graph */
    status = vnn_ProcessGraph( graph );
    TEST_CHECK_STATUS( status, final );

    if(VNN_APP_DEBUG)
    {
        /* Dump all node outputs */
        vsi_nn_DumpGraphNodeOutputs(graph, "./network_dump", NULL, 0, TRUE, 0);
    }

    /* Post process output data */
    status = vnn_PostProcessNeuralNetwork( graph );
    TEST_CHECK_STATUS( status, final );

final:
    vnn_ReleaseNeuralNetwork( graph );
    fflush(stdout);
    fflush(stderr);
    return status;
}

